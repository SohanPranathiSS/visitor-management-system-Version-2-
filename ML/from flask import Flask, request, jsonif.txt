from flask import Flask, request, jsonify
from flask_cors import CORS
from PIL import Image
import numpy as np
import io
import easyocr
import re
import cv2
import os
from werkzeug.utils import secure_filename

app = Flask(__name__)
# CORS configuration for both endpoints
CORS(app, resources={r"/extract-id-number": {"origins": "http://localhost:3000"}, r"/upload": {"origins": "http://localhost:3000"}})

# Configuration for file uploads
app.config['UPLOAD_FOLDER'] = 'static/uploads'
ALLOWED_EXTENSIONS = {'jpg', 'jpeg', 'png'}

# Initialize OCR Reader (one-time setup for efficiency)
reader = easyocr.Reader(['en'], gpu=False)

def allowed_file(filename):
    """Checks if the uploaded file has an allowed extension."""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def preprocess_and_rotate(image):
    """Preprocesses the image for better OCR results, including rotation."""
    img = np.array(image.convert("RGB"))
    
    # Rotate image if it's taller than it is wide
    h, w, _ = img.shape
    if h > w:
        img = cv2.rotate(img, cv2.ROTATE_90_COUNTERCLOCKWISE)
        
    # Convert to grayscale and apply sharpening
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    sharpen_kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
    sharp = cv2.filter2D(gray, -1, sharpen_kernel)
    
    # Apply thresholding
    _, thresh = cv2.threshold(sharp, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    return thresh, img

def extract_text_and_numbers(image_np):
    """Extracts text and numbers from an image using EasyOCR."""
    results = reader.readtext(image_np, detail=0, paragraph=False)
    full_text = ' '.join(results)
    
    # Extract Aadhar (12 digits, with optional spaces) and PAN (10 alphanumeric characters)
    aadhar_pattern = r'\b(?:\d{4}\s?\d{4}\s?\d{4}|\d{12})\b'
    pan_pattern = r'\b[A-Z]{5}\d{4}[A-Z]\b'
    numbers = re.findall(f'{aadhar_pattern}|{pan_pattern}', full_text)
    return numbers, results

def extract_email(text):
    """Extracts email addresses using regex."""
    match = re.search(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', text)
    return match.group(0) if match else None

def extract_mobile_number(text):
    """Extracts a mobile number with support for various formats."""
    # Enhanced mobile patterns for different countries and formats
    mobile_patterns = [
        # Indian mobile numbers
        r'\+91[-\s]?([6-9]\d{9})\b',  # +91 followed by mobile number
        r'\b91[-\s]?([6-9]\d{9})\b',   # 91 followed by mobile number (without +)
        r'\b([6-9]\d{9})\b',           # Direct 10-digit mobile number
        # US numbers
        r'\+1[-\s]?(\d{3})[-\s]?(\d{3})[-\s]?(\d{4})\b',
        r'\b(\d{3})[-\s]?(\d{3})[-\s]?(\d{4})\b',
        # UK numbers
        r'\+44[-\s]?(\d{4})[-\s]?(\d{6})\b',
        # General international format
        r'\+(\d{1,3})[-\s]?(\d{8,12})\b'
    ]
    
    for pattern in mobile_patterns:
        matches = re.findall(pattern, text)
        for match in matches:
            if isinstance(match, tuple):
                # Handle tuple matches (grouped patterns)
                if len(match) == 1:  # Indian format
                    number = match[0]
                    # Ensure it's not part of a longer number (like landline with extension)
                    full_match = re.search(r'\+?91?[-\s]?' + re.escape(number) + r'(?!\s*(?:ext|extension|x))', text, re.IGNORECASE)
                    if full_match:
                        return full_match.group(0).strip()
                elif len(match) == 3:  # US format
                    return f"{match[0]}-{match[1]}-{match[2]}"
                elif len(match) == 2:  # UK or international
                    return f"+{match[0]}-{match[1]}" if match[0].isdigit() else f"{match[0]}-{match[1]}"
            else:
                # Handle string matches
                full_match = re.search(r'\+?91?[-\s]?' + re.escape(match) + r'(?!\s*(?:ext|extension|x))', text, re.IGNORECASE)
                if full_match:
                    return full_match.group(0).strip()
    
    return None

def extract_company_number(text):
    """Extracts a company landline number with support for various formats."""
    # Enhanced patterns for different landline formats
    patterns = [
        # Indian landline numbers
        r'(\+91[-\s]*(?:0?[1-5]\d|40|80|11|22|33|44|20|79|484|422|471)[-\s]*\d{6,8})(\s*(?:ext|extension|x)[-:\s]*\d+)?',
        r'(\+91[-\s]*0\d{2,4}[-\s]*\d{6,8})(\s*(?:ext|extension|x)[-:\s]*\d+)?',
        # US landline numbers
        r'(\+1[-\s]*\d{3}[-\s]*\d{3}[-\s]*\d{4})(\s*(?:ext|extension|x)[-:\s]*\d+)?',
        r'(\d{3}[-\s]*\d{3}[-\s]*\d{4})(\s*(?:ext|extension|x)[-:\s]*\d+)?',
        # UK landline numbers
        r'(\+44[-\s]*\d{3,4}[-\s]*\d{6,7})(\s*(?:ext|extension|x)[-:\s]*\d+)?',
        # With prefixes
        r'(?:tel|phone|ph|office|off|landline)[-:\s]*(\+?91?[-\s]*\d{2,4}[-\s]*\d{6,8})(\s*(?:ext|extension|x)[-:\s]*\d+)?',
        # Generic international
        r'(\+\d{1,3}[-\s]*\d{6,12})(\s*(?:ext|extension|x)[-:\s]*\d+)?'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            number = match.group(1).strip()
            extension = match.group(2).strip() if match.group(2) else None
            
            # Extract just the digits to check
            clean_number = re.sub(r'[^\d]', '', number)
            
            # Skip if it's likely a mobile number
            if len(clean_number) == 10:
                # Check if it starts with mobile prefixes for different countries
                if clean_number[0] in '6789':  # Indian mobile
                    continue
                if clean_number[:3] in ['800', '888', '877', '866', '855', '844', '833', '822']:  # US toll-free
                    continue
                    
            # Skip very short numbers that are likely not valid
            if len(clean_number) < 6:
                continue
                
            # Format the result
            result = number
            if extension:
                result += f" {extension}"
            return result.strip()
    
    return None

def extract_website(text):
    """Extracts a website URL with improved pattern matching."""
    # More comprehensive website patterns
    patterns = [
        r'\b(?:https?://)?(?:www\.)?([a-zA-Z0-9-]+\.(?:com|in|org|net|edu|gov|co\.in|co\.uk|biz|info))\b',
        r'\bwww\.([a-zA-Z0-9-]+\.(?:com|in|org|net|edu|gov|co\.in|co\.uk|biz|info))\b',
        r'\b([a-zA-Z0-9-]+\.(?:com|in|org|net|edu|gov|co\.in|co\.uk|biz|info))\b'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            website = match.group(1) if match.group(1) else match.group(0)
            # Clean up the website
            website = website.lower()
            if not website.startswith('www.') and not website.startswith('http'):
                website = 'www.' + website
            return website
    
    return None

def extract_company_name(lines):
    """Extracts company name based on keywords and patterns."""
    # Company indicators - expanded list
    company_keywords = [
        'services', 'solutions', 'pvt', 'ltd', 'limited', 'software', 'technologies', 'tech',
        'systems', 'corp', 'corporation', 'company', 'co', 'inc', 'incorporated', 'enterprises',
        'consulting', 'consultancy', 'group', 'international', 'global', 'industries',
        'foundation', 'institute', 'academy', 'center', 'centre'
    ]
    
    # Look for lines with company keywords
    for line in lines:
        line_clean = line.strip()
        if any(keyword in line.lower() for keyword in company_keywords):
            return line_clean.title()
    
    # If no keywords found, look for lines that might be company names
    # (usually longer lines that aren't obviously names, emails, or addresses)
    potential_companies = []
    for line in lines:
        line_clean = line.strip()
        line_lower = line_clean.lower()
        
        # Skip obvious non-company content
        if (any(skip in line_lower for skip in ['@', 'www', '.com', '+91', 'phone', 'mobile', 'tel']) or
            re.match(r'^[A-Z][a-z]+\s[A-Z][a-z]+$', line_clean) or  # Likely names
            len(line_clean.split()) <= 1):  # Single words
            continue
            
        # Look for lines that could be company names
        if (len(line_clean.split()) >= 2 and 
            len(line_clean) > 10 and
            not line_clean.isdigit()):
            potential_companies.append(line_clean.title())
    
    # Return the longest potential company name
    if potential_companies:
        return max(potential_companies, key=len)
    
    return "Not Found"

def extract_address(lines):
    """Extracts address by identifying address-related keywords."""
    address_parts = []
    # Expanded address keywords for different regions/formats
    address_keywords = [
        'block', 'house', 'road', 'street', 'nagar', 'colony', 'sector', 'phase', 'plot',
        'avenue', 'ave', 'boulevard', 'blvd', 'lane', 'ln', 'drive', 'dr', 'court', 'ct',
        'circle', 'place', 'plaza', 'square', 'park', 'building', 'floor', 'suite',
        'apartment', 'apt', 'unit', 'tower', 'complex', 'estate', 'enclave', 'layout',
        # Indian specific
        'gumpet', 'begumpet', 'nagar', 'pura', 'abad', 'ganj', 'wadi', 'gaon', 'khurd',
        # Cities and states
        'hyderabad', 'bangalore', 'mumbai', 'delhi', 'chennai', 'kolkata', 'pune', 'ahmedabad',
        'ts', 'telangana', 'karnataka', 'maharashtra', 'gujarat', 'tamil nadu', 'west bengal',
        'india', 'bharat', r'\b\d{5,6}\b',  # Pincode pattern
        # Common address words
        'white', 'near', 'opposite', 'behind', 'beside', 'cross', 'main', 'sub'
    ]
    
    non_address_keywords = [
        '@', 'www', '.com', '.in', '.org', '.net', 'phone', 'mobile', 'email', 'tel',
        'services', 'solutions', 'pvt', 'ltd', r'\+91', 'director', 'manager', 'strategy', 
        'delivery', 'ceo', 'founder', 'president', 'vice', 'senior', 'junior', 'executive'
    ]
    
    # Names to exclude from address (more generic patterns)
    name_patterns = [
        r'\b(?:director|manager|ceo|founder|president|vice|senior|junior|executive)\b',
        r'\b[A-Z][a-z]+\s[A-Z][a-z]+\b'  # Simple name pattern
    ]
    
    # First, find the starting point of the address
    start_index = -1
    for i, line in enumerate(lines):
        line_lower = line.lower()
        # Look for address indicators
        if any(re.search(keyword, line_lower) for keyword in address_keywords):
            # Make sure it's not a line with non-address content
            if not any(re.search(keyword, line_lower) for keyword in non_address_keywords):
                start_index = i
                break
    
    if start_index != -1:
        # Collect address lines starting from the found index
        for i in range(start_index, len(lines)):
            line = lines[i].strip()
            if not line: 
                continue
                
            line_lower = line.lower()
            
            # Stop if we hit clear non-address content
            if any(re.search(keyword, line_lower) for keyword in non_address_keywords):
                break
            
            # Skip lines that contain person names or titles
            if any(re.search(pattern, line_lower) for pattern in name_patterns):
                continue
                
            # Stop if we hit a person's name (but not if it contains address keywords)
            if (line.count(' ') <= 2 and 
                re.match(r'^[A-Z][a-z]+(?:\s[A-Z][a-z]+)*$', line) and 
                not any(re.search(keyword, line_lower) for keyword in address_keywords)):
                break
            
            # Add the line to address if it looks like address content
            if (any(re.search(keyword, line_lower) for keyword in address_keywords) or 
                len(address_parts) > 0):  # Continue adding if we've already started
                
                # Clean up common OCR errors and formatting
                cleaned_line = line
                # OCR corrections for Roman numerals
                cleaned_line = re.sub(r'\bIil\b', 'III', cleaned_line, flags=re.IGNORECASE)
                cleaned_line = re.sub(r'\bIii\b', 'III', cleaned_line, flags=re.IGNORECASE)
                cleaned_line = re.sub(r'\blil\b', 'III', cleaned_line, flags=re.IGNORECASE)
                cleaned_line = re.sub(r'\blii\b', 'III', cleaned_line, flags=re.IGNORECASE)
                cleaned_line = re.sub(r'\bIV\b', 'IV', cleaned_line, flags=re.IGNORECASE)
                cleaned_line = re.sub(r'\bVI\b', 'VI', cleaned_line, flags=re.IGNORECASE)
                # Punctuation fixes
                cleaned_line = cleaned_line.replace(';', ',')
                cleaned_line = cleaned_line.replace('  ', ' ')  # Multiple spaces
                
                # Skip lines that are just single digits or very short non-meaningful content
                if (len(cleaned_line.strip()) <= 2 and 
                    cleaned_line.strip().isdigit() and 
                    not any(keyword in line_lower for keyword in address_keywords)):
                    continue
                
                address_parts.append(cleaned_line)
                
            # Stop after we've collected a reasonable number of address lines
            if len(address_parts) >= 4 and any(re.search(keyword, line_lower) for keyword in ['india', 'bharat', r'\b\d{5,6}\b']):
                break
    
    # Look for pincode separately if not found in address
    pincode = None
    for line in lines:
        pincode_match = re.search(r'\b(\d{5,6})\b', line)  # 5-6 digit codes
        if pincode_match and len(pincode_match.group(1)) >= 5:
            pincode = pincode_match.group(1)
            break
    
    # If pincode found and not already in address, add it
    if pincode and not any(pincode in part for part in address_parts):
        if address_parts and any(country in address_parts[-1].lower() for country in ['india', 'bharat']):
            # Add pincode to the last part if it contains country name
            address_parts[-1] = address_parts[-1] + f" - {pincode}"
        else:
            address_parts.append(pincode)
    
    # If no address found with keywords, look for multi-line text blocks that might be addresses
    if not address_parts:
        potential_address = []
        for i, line in enumerate(lines):
            line_clean = line.strip()
            line_lower = line_clean.lower()
            
            # Skip obvious non-address lines
            if (any(re.search(keyword, line_lower) for keyword in non_address_keywords) or
                re.match(r'^[A-Z][a-z]+\s[A-Z][a-z]+$', line_clean) or  # Names
                len(line_clean.split()) <= 1 or  # Single words
                line_clean.startswith('+') or '@' in line_clean):  # Phone/email
                continue
                
            # Look for lines that might be address components
            if (len(line_clean.split()) >= 2 and len(line_clean) > 5):
                potential_address.append(line_clean)
                
        # Take a reasonable sequence that might be an address
        if len(potential_address) >= 2:
            address_parts = potential_address[:4]  # Limit to first 4 lines
    
    # Final cleanup: remove any stray single digits or very short meaningless parts
    cleaned_address_parts = []
    for part in address_parts:
        part = part.strip()
        # Skip single digits unless they're part of a larger address component
        if len(part) <= 2 and part.isdigit() and part != pincode:
            continue
        if part:  # Only add non-empty parts
            cleaned_address_parts.append(part)
    
    return ', '.join(cleaned_address_parts).title().replace(" ,", ",") if cleaned_address_parts else "Not Found"

def extract_name_and_designation(lines):
    """Extracts name and designation based on keywords and positioning."""
    name = None
    designation = None
    
    # Expanded designation keywords
    designation_keywords = [
        # Management titles
        'director', 'manager', 'ceo', 'cto', 'cfo', 'coo', 'president', 'vice president', 'vp',
        'founder', 'co-founder', 'owner', 'partner', 'principal', 'head', 'lead', 'chief',
        # Technical titles
        'engineer', 'developer', 'architect', 'analyst', 'consultant', 'specialist', 'expert',
        'technician', 'programmer', 'designer', 'administrator', 'coordinator', 'supervisor',
        # Sales/Marketing
        'sales', 'marketing', 'business development', 'account', 'relationship', 'executive',
        # Operations
        'operations', 'strategy', 'delivery', 'project', 'product', 'service', 'quality',
        # Levels
        'senior', 'junior', 'associate', 'assistant', 'deputy', 'team lead', 'team leader'
    ]
    
    # First pass: look for explicit designation lines
    for i, line in enumerate(lines):
        line_lower = line.lower()
        line_clean = line.strip()
        
        if any(keyword in line_lower for keyword in designation_keywords):
            designation = line_clean.title()
            
            # Look for name in nearby lines (before the designation)
            for j in range(max(0, i - 3), i):
                potential_name = lines[j].strip()
                # Check if it looks like a name (2-3 words, proper case)
                if (re.match(r'^[A-Z][a-z]+(?:\s[A-Z][a-z]+){1,2}$', potential_name) and
                    len(potential_name.split()) <= 3 and
                    not any(keyword in potential_name.lower() for keyword in designation_keywords) and
                    '@' not in potential_name and '+' not in potential_name):
                    name = potential_name.title()
                    break
            if name:
                break
    
    # Second pass: if designation found but no name, extract from designation line
    if designation and not name:
        parts = designation.split()
        # Check if first few words might be a name
        if len(parts) >= 3:
            potential_name_parts = []
            for part in parts:
                if any(keyword in part.lower() for keyword in designation_keywords):
                    break
                if re.match(r'^[A-Z][a-z]+$', part):
                    potential_name_parts.append(part)
                    
            if len(potential_name_parts) >= 2:
                name = ' '.join(potential_name_parts)
    
    # Third pass: if no name found yet, look for standalone name-like lines
    if not name:
        potential_names = []
        for line in lines:
            line_clean = line.strip()
            line_lower = line_clean.lower()
            
            # Skip lines with non-name content
            if (any(kw in line_lower for kw in designation_keywords + ['@', '.com', '.in', 'www', 'phone', 'tel', 'mobile']) or
                any(char in line_clean for char in ['+', '@', '.']) or
                len(line_clean.split()) > 4 or  # Too long to be a name
                len(line_clean.split()) < 2):   # Too short
                continue
                
            # Check if it looks like a name
            if re.match(r'^[A-Z][a-z]+(?:\s[A-Z][a-z]+){1,2}$', line_clean):
                potential_names.append(line_clean.title())
        
        # Choose the most likely name (prefer shorter, cleaner names)
        if potential_names:
            # Sort by length and pick the shortest reasonable name
            potential_names.sort(key=len)
            name = potential_names[0]
    
    # Clean up designation if found
    if designation:
        # Remove common prefixes/suffixes that might be picked up
        designation = re.sub(r'^(mr\.?|ms\.?|mrs\.?|dr\.?)\s+', '', designation, flags=re.IGNORECASE)
        designation = re.sub(r'\s+(ltd\.?|pvt\.?|inc\.?|corp\.?)$', '', designation, flags=re.IGNORECASE)
    
    return name, designation

@app.route('/extract-id-number', methods=['POST'])
def extract_id_number():
    """Extract Aadhar, PAN, and general numbers from an uploaded image."""
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400

    try:
        # Open and preprocess the image
        image = Image.open(file.stream)
        processed_img, _ = preprocess_and_rotate(image)
        number_results, text_results = extract_text_and_numbers(processed_img)
        print('Extracted numbers:', number_results)  # Debug
        print('Full OCR results:', text_results)  # Debug

        # Clean numbers (remove spaces for Aadhar and PAN)
        cleaned_numbers = []
        for num in number_results:
            cleaned = re.sub(r'\s+', '', num)
            cleaned_numbers.append(cleaned)

        # Construct response
        response = {
            'Aadhar': [num for num in cleaned_numbers if re.match(r'^\d{12}$', num)],
            'PAN': [num for num in cleaned_numbers if re.match(r'^[A-Z]{5}\d{4}[A-Z]$', num)],
            'General Numbers': cleaned_numbers  # All numbers, cleaned
        }
        print('Response:', response)  # Debug
        return jsonify(response), 200
    except Exception as e:
        print('Error processing image:', str(e))  # Debug
        return jsonify({'error': f'Failed to process image: {str(e)}'}), 500

@app.route('/upload', methods=['POST'])
def upload_image():
    """Extract business card details (name, email, company, etc.) from an uploaded image."""
    if 'file' not in request.files:
        return jsonify({"error": "No file part"}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400
        
    if file and allowed_file(file.filename):
        try:
            image = Image.open(file.stream)
            processed_img, _ = preprocess_and_rotate(image)
            
            results = reader.readtext(processed_img, detail=0, paragraph=False)
            full_text = ' '.join(results)
            
            # Debug: Print extracted text to help identify issues
            print("=== OCR EXTRACTED TEXT ===")
            print("Full text:", full_text)
            print("Individual lines:", results)
            print("========================")
            
            email = extract_email(full_text)
            mobile_number = extract_mobile_number(full_text)
            print("Found mobile number:", mobile_number)  # Debug line
            company_number = extract_company_number(full_text)
            print("Found company number:", company_number)  # Debug line
            
            # Additional debug: Show all phone-like numbers found
            all_phone_numbers = re.findall(r'\+91[-\s]*\d{2,4}[-\s]*\d{6,10}(?:\s*(?:ext|extension|x)[-:\s]*\d+)?', full_text, re.IGNORECASE)
            print("All phone-like patterns found:", all_phone_numbers)
            
            website = extract_website(full_text)
            name, designation = extract_name_and_designation(results)
            company = extract_company_name(results)
            if company == "Not Found" and email:
                company = email.split('@')[1].split('.')[0].capitalize()
            address = extract_address(results)
            print("Found address:", address)  # Debug line
            
            response_data = {
                "name": name if name else "Not Found",
                "designation": designation if designation else "Not Found",
                "company": company if company else "Not Found",
                "email": email if email else "Not Found",
                "personal_mobile_number": mobile_number if mobile_number else "Not Found",
                "company_number": company_number if company_number else "Not Found",
                "website": website if website else "Not Found",
                "address": address if address else "Not Found",
            }
            return jsonify(response_data), 200
            
        except Exception as e:
            return jsonify({"error": f"An error occurred during processing: {e}"}), 500
    else:
        return jsonify({"error": "Invalid file type. Allowed types: jpg, jpeg, png"}), 400

if __name__ == '__main__':
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
    app.run(host='0.0.0.0', port=5000, debug=True)